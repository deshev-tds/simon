<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simon Admin Metrics</title>
    <style>
      :root {
        color-scheme: light dark;
        --border: rgba(0, 0, 0, 0.2);
        --header: rgba(0, 0, 0, 0.06);
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --border: rgba(255, 255, 255, 0.2);
          --header: rgba(255, 255, 255, 0.08);
        }
      }
      body {
        margin: 16px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 13px;
        line-height: 1.4;
        background: Canvas;
        color: CanvasText;
      }
      h1 {
        font-size: 16px;
        margin: 0 0 8px 0;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin-bottom: 12px;
        align-items: flex-start;
      }
      .box {
        border: 1px solid var(--border);
        padding: 8px;
        min-width: 220px;
      }
      .field {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .field input {
        min-width: 220px;
        padding: 4px 6px;
        border: 1px solid var(--border);
        background: Canvas;
        color: CanvasText;
        font-family: inherit;
        font-size: 12px;
      }
      .field select {
        min-width: 220px;
        padding: 4px 6px;
        border: 1px solid var(--border);
        background: Canvas;
        color: CanvasText;
        font-family: inherit;
        font-size: 12px;
      }
      .field button {
        padding: 4px 8px;
        border: 1px solid var(--border);
        background: Canvas;
        color: CanvasText;
        font-family: inherit;
        font-size: 12px;
        cursor: pointer;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th, td {
        border: 1px solid var(--border);
        padding: 4px 6px;
        text-align: left;
        white-space: nowrap;
      }
      th {
        background: var(--header);
      }
      .muted {
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <h1>Simon Metrics</h1>
    <div class="row">
      <div class="box">
        <div id="status">Status: loading...</div>
        <div id="updated" class="muted"></div>
      </div>
      <div class="box">
        <div id="summary">Summary: -</div>
      </div>
      <div class="box">
        <div class="muted">API Base</div>
        <div class="field" style="margin-top: 6px;">
          <input id="apiBase" placeholder="(same origin)" />
          <button id="applyApi">Apply</button>
          <button id="resetApi">Reset</button>
        </div>
      </div>
      <div class="box" style="min-width: 340px;">
        <div class="muted">Llama Control</div>
        <div id="llamaStatus" style="margin-top: 6px;">llama: -</div>
        <div class="field" style="margin-top: 6px; flex-wrap: wrap;">
          <button id="llamaRefresh">Scan</button>
          <button id="llamaStatusBtn">Status</button>
          <button id="llamaEject">Eject</button>
        </div>
        <div class="muted" style="margin-top: 8px;">Model</div>
        <div class="field" style="margin-top: 6px;">
          <select id="llamaModelSelect" style="min-width: 300px;"></select>
        </div>
        <div class="field" style="margin-top: 8px;">
          <button id="llamaSwitch">Switch (load)</button>
        </div>
        <div id="llamaMsg" class="muted" style="margin-top: 6px; white-space: pre-wrap;"></div>
      </div>
    </div>
    <table>
      <thead>
        <tr>
          <th>Time</th>
          <th>ID</th>
          <th>Mode</th>
          <th>Status</th>
          <th>Audio B</th>
          <th>Decode</th>
          <th>STT</th>
          <th>Partial</th>
          <th>Final</th>
          <th>RTF</th>
          <th>RAG</th>
          <th>CTX</th>
          <th>TTFT</th>
          <th>LLM</th>
          <th>TTS First</th>
          <th>TTS Total</th>
          <th>In Tks</th>
          <th>Out Tks</th>
          <th>TPS</th>
          <th>Overhead</th>
          <th>Total</th>
        </tr>
      </thead>
      <tbody id="metrics-body"></tbody>
    </table>

    <script>
      const statusEl = document.getElementById('status');
      const updatedEl = document.getElementById('updated');
      const summaryEl = document.getElementById('summary');
      const bodyEl = document.getElementById('metrics-body');
      const apiInput = document.getElementById('apiBase');
      const applyButton = document.getElementById('applyApi');
      const resetButton = document.getElementById('resetApi');
      const llamaStatusEl = document.getElementById('llamaStatus');
      const llamaRefreshBtn = document.getElementById('llamaRefresh');
      const llamaStatusBtn = document.getElementById('llamaStatusBtn');
      const llamaEjectBtn = document.getElementById('llamaEject');
      const llamaSwitchBtn = document.getElementById('llamaSwitch');
      const llamaModelSelect = document.getElementById('llamaModelSelect');
      const llamaMsgEl = document.getElementById('llamaMsg');

      const STORAGE_KEY = 'simon_admin_api_base';
      const normalizeBase = (value) => value.replace(/\/+$/, '');
      const params = new URLSearchParams(location.search);
      const paramBase = params.get('api');
      if (paramBase) {
        localStorage.setItem(STORAGE_KEY, normalizeBase(paramBase));
      }
      let apiBase = normalizeBase(localStorage.getItem(STORAGE_KEY) || '');
      apiInput.value = apiBase;

      const fmt = (value, digits = 3) => {
        if (typeof value !== 'number' || Number.isNaN(value)) return '-';
        return value.toFixed(digits);
      };

      const fmtInt = (value) => {
        if (typeof value !== 'number' || Number.isNaN(value)) return '-';
        return Math.round(value).toString();
      };

      const fmtTime = (unixSeconds) => {
        if (!unixSeconds) return '-';
        const d = new Date(unixSeconds * 1000);
        return d.toLocaleTimeString();
      };

      const avg = (items, key, predicate) => {
        let sum = 0;
        let count = 0;
        for (const item of items) {
          if (predicate && !predicate(item)) continue;
          const value = item[key];
          if (typeof value !== 'number' || Number.isNaN(value)) continue;
          sum += value;
          count += 1;
        }
        return { value: count ? sum / count : 0, count };
      };

      const render = (items) => {
        bodyEl.innerHTML = '';
        const rows = [...items].reverse();
        for (const item of rows) {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${fmtTime(item.start_time)}</td>
            <td>${item.id || '-'}</td>
            <td>${item.mode || '-'}</td>
            <td>${item.status || '-'}</td>
            <td>${item.audio_bytes ?? 0}</td>
            <td>${fmt(item.audio_decode)}</td>
            <td>${fmt(item.stt)}</td>
            <td>${fmt(item.partial_latency)}</td>
            <td>${fmt(item.final_latency)}</td>
            <td>${fmt(item.stt_rtf, 2)}</td>
            <td>${fmt(item.rag)}</td>
            <td>${fmt(item.ctx)}</td>
            <td>${fmt(item.ttft)}</td>
            <td>${fmt(item.llm_total)}</td>
            <td>${fmt(item.tts_first)}</td>
            <td>${fmt(item.tts_total)}</td>
            <td>${fmtInt(item.input_tokens)}</td>
            <td>${fmtInt(item.output_tokens)}</td>
            <td>${fmt(item.tokens_per_second, 2)}</td>
            <td>${fmt(item.overhead)}</td>
            <td>${fmt(item.total_latency)}</td>
          `;
          bodyEl.appendChild(tr);
        }

        if (items.length) {
          const okItems = items.filter((item) => item.status === 'ok');
          const voiceItems = okItems.filter((item) => item.mode === 'voice');
          const decodeAvg = avg(voiceItems, 'audio_decode');
          const sttAvg = avg(voiceItems, 'stt');
          const partialAvg = avg(voiceItems, 'partial_latency');
          const finalAvg = avg(voiceItems, 'final_latency');
          const rtfAvg = avg(voiceItems, 'stt_rtf');
          const ttftAvg = avg(okItems, 'ttft');
          const llmAvg = avg(okItems, 'llm_total');
          const ttsAvg = avg(voiceItems, 'tts_total');
          const inTokAvg = avg(okItems, 'input_tokens');
          const outTokAvg = avg(okItems, 'output_tokens');
          const tpsAvg = avg(okItems, 'tokens_per_second');
          const overheadAvg = avg(okItems, 'overhead');
          const totalAvg = avg(okItems, 'total_latency');

          summaryEl.textContent =
            `Summary: n=${items.length} ok=${okItems.length} ` +
            `avg(decode=${fmt(decodeAvg.value)}s/${decodeAvg.count} ` +
            `stt=${fmt(sttAvg.value)}s/${sttAvg.count} ` +
            `partial=${fmt(partialAvg.value)}s/${partialAvg.count} ` +
            `final=${fmt(finalAvg.value)}s/${finalAvg.count} ` +
            `rtf=${fmt(rtfAvg.value, 2)}/${rtfAvg.count} ` +
            `ttft=${fmt(ttftAvg.value)}s/${ttftAvg.count} ` +
            `llm=${fmt(llmAvg.value)}s/${llmAvg.count} ` +
            `tts=${fmt(ttsAvg.value)}s/${ttsAvg.count} ` +
            `in=${fmt(inTokAvg.value, 0)}/${inTokAvg.count} ` +
            `out=${fmt(outTokAvg.value, 0)}/${outTokAvg.count} ` +
            `tps=${fmt(tpsAvg.value, 2)}/${tpsAvg.count} ` +
            `overhead=${fmt(overheadAvg.value)}s/${overheadAvg.count} ` +
            `total=${fmt(totalAvg.value)}s/${totalAvg.count})`;
        } else {
          summaryEl.textContent = 'Summary: -';
        }
      };

      const getBase = () => (apiBase ? apiBase : location.origin);
      const apiFetch = (path, init) => fetch(`${getBase()}${path}`, init);

      // --- LLAMA CONTROL ---
      let llamaModels = [];
      let llamaLastStatus = null;

      const setLlamaMsg = (text) => {
        llamaMsgEl.textContent = text || '';
      };

      const modelValue = (model) => (model?.id || model?.path || '');
      const modelLabel = (model) => {
        const base = model?.id || model?.rel || model?.path || '';
        const status = model?.status ? ` [${model.status}]` : '';
        return `${base}${status}`;
      };

      const populateModels = () => {
        llamaModelSelect.innerHTML = '';
        for (const m of llamaModels) {
          const opt = document.createElement('option');
          opt.value = modelValue(m);
          opt.textContent = modelLabel(m);
          llamaModelSelect.appendChild(opt);
        }
      };

      llamaModelSelect.addEventListener('change', () => {
        // No-op; kept for symmetry if we add per-model controls later.
      });

      const fetchLlamaStatus = async () => {
        try {
          const res = await apiFetch('/admin/llama/status');
          const text = await res.text();
          if (!res.ok) throw new Error(text || `HTTP ${res.status}`);
          const data = JSON.parse(text);
          llamaLastStatus = data;
          if (data?.source === 'router') {
            const loaded = Array.isArray(data?.loaded) ? data.loaded : [];
            const current = data?.current ? ` current=${data.current}` : '';
            llamaStatusEl.textContent = `llama: router loaded=${loaded.length}${current}`;
          } else {
            const label = data?.running ? `RUNNING pid=${data.pid || '-'} port=${data.port || '-'}`
                                       : 'STOPPED';
            const model = data?.model_path ? ` model=${data.model_path.split('/').pop()}` : '';
            llamaStatusEl.textContent = `llama: ${label}${model}`;
          }
          return data;
        } catch (err) {
          llamaStatusEl.textContent = `llama: error (${err.message})`;
          return null;
        }
      };

      const scanLlamaModels = async () => {
        if (location.protocol === 'file:' && !apiBase) {
          setLlamaMsg('Set API Base (file:// has no origin).');
          return;
        }
        setLlamaMsg('Scanning models...');
        try {
          const res = await apiFetch('/admin/llama/models?refresh=1');
          const text = await res.text();
          if (!res.ok) throw new Error(text || `HTTP ${res.status}`);
          const data = JSON.parse(text);
          llamaModels = Array.isArray(data?.models) ? data.models : [];
          populateModels();
          setLlamaMsg(`Found ${llamaModels.length} model(s).`);
        } catch (err) {
          setLlamaMsg(`Scan failed: ${err.message}`);
        }
      };

      const switchLlamaModel = async () => {
        const model = llamaModelSelect.value || '';
        if (!model) {
          setLlamaMsg('Pick a model first.');
          return;
        }
        setLlamaMsg('Switching model (load)...');
        try {
          const res = await apiFetch('/admin/llama/switch', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ model }),
          });
          const text = await res.text();
          if (!res.ok) throw new Error(text || `HTTP ${res.status}`);
          const data = JSON.parse(text);
          setLlamaMsg(`Switched. Active OpenAI model id: ${data?.active_model || '-'}`);
          await fetchLlamaStatus();
        } catch (err) {
          setLlamaMsg(`Switch failed: ${err.message}`);
        }
      };

      const ejectLlama = async () => {
        setLlamaMsg('Ejecting (stop server)...');
        try {
          const res = await apiFetch('/admin/llama/eject', { method: 'POST' });
          const text = await res.text();
          if (!res.ok) throw new Error(text || `HTTP ${res.status}`);
          setLlamaMsg('Ejected (server stopped).');
          await fetchLlamaStatus();
        } catch (err) {
          setLlamaMsg(`Eject failed: ${err.message}`);
        }
      };

      const tryFetch = async () => {
        const url = `${getBase()}/metrics?limit=50`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      };

      const channel = window.BroadcastChannel ? new BroadcastChannel('simon-metrics') : null;
      const tabId = Math.random().toString(36).slice(2);
      let isLeader = false;
      let pollTimer = null;
      let lastLeaderSeen = 0;
      let leaderId = null;

      const updateStatus = (text) => {
        statusEl.textContent = text;
        updatedEl.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
      };

      const startPolling = () => {
        if (pollTimer) return;
        isLeader = true;
        fetchMetrics();
        pollTimer = setInterval(fetchMetrics, 2000);
      };

      const stopPolling = () => {
        if (!pollTimer) return;
        clearInterval(pollTimer);
        pollTimer = null;
        isLeader = false;
      };

      const fetchMetrics = async () => {
        if (location.protocol === 'file:' && !apiBase) {
          statusEl.textContent = 'Status: set API Base (file:// has no origin)';
          return;
        }
        try {
          const data = await tryFetch();
          render(data.items || []);
          updateStatus(`Status: ok (${getBase()})${isLeader ? ' leader' : ''}`);
          if (channel) {
            channel.postMessage({ type: 'metrics', id: tabId, base: getBase(), items: data.items || [] });
          }
        } catch (err) {
          statusEl.textContent = `Status: error (${err.message})`;
        }
      };

      if (channel) {
        channel.onmessage = (event) => {
          const msg = event.data || {};
          if (msg.type === 'leader') {
            leaderId = msg.id;
            lastLeaderSeen = Date.now();
            if (leaderId !== tabId) stopPolling();
            return;
          }
          if (msg.type === 'metrics' && msg.base === getBase()) {
            leaderId = msg.id || leaderId;
            lastLeaderSeen = Date.now();
            render(msg.items || []);
            updateStatus(`Status: ok (${msg.base}) follower`);
          }
        };
      }

      const electLeader = () => {
        if (location.protocol === 'file:' && !apiBase) {
          stopPolling();
          statusEl.textContent = 'Status: set API Base (file:// has no origin)';
          return;
        }
        if (!channel) {
          startPolling();
          return;
        }
        const now = Date.now();
        if (!leaderId || now - lastLeaderSeen > 5000) {
          leaderId = tabId;
          lastLeaderSeen = now;
          channel.postMessage({ type: 'leader', id: tabId });
          startPolling();
        }
      };

      applyButton.addEventListener('click', () => {
        apiBase = normalizeBase(apiInput.value.trim());
        apiInput.value = apiBase;
        localStorage.setItem(STORAGE_KEY, apiBase);
        if (channel) {
          channel.postMessage({ type: 'leader', id: tabId });
        }
        stopPolling();
        electLeader();
      });

      resetButton.addEventListener('click', () => {
        apiBase = '';
        apiInput.value = '';
        localStorage.removeItem(STORAGE_KEY);
        if (channel) {
          channel.postMessage({ type: 'leader', id: tabId });
        }
        stopPolling();
        electLeader();
      });

      llamaRefreshBtn.addEventListener('click', scanLlamaModels);
      llamaStatusBtn.addEventListener('click', fetchLlamaStatus);
      llamaSwitchBtn.addEventListener('click', switchLlamaModel);
      llamaEjectBtn.addEventListener('click', ejectLlama);

      electLeader();
      setInterval(electLeader, 2000);

      // Best-effort initial state.
      fetchLlamaStatus();
      scanLlamaModels();
    </script>
  </body>
</html>
